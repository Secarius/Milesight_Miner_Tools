# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'minertools_gui_main_window.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.

#####################################################################
import os
import sys
import psutil
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtWidgets import QMainWindow, QAction, qApp, QApplication
import tkinter as tk
from tkinter import ttk
from tkinter import messagebox
import tkinter.font as tkFont
from PIL import Image, ImageTk
from zipfile import ZipFile
import subprocess
from asyncio import subprocess
from subprocess import Popen
from fnmatch import fnmatch
from pprint import pprint
import requests
import json
import urllib.request
from email.mime import image
import threading
import ipaddress
import socket
from numpy import genfromtxt
from packaging import version
import pathlib
from assets import images_rc
from src import ssh_comms
from paramiko import SSHClient, AutoAddPolicy
import time
import webbrowser
import numpy

version_build = "1.2.6"
dir_path = '%s\\MinerTools\\' % os.environ['APPDATA'] 
if not os.path.exists(dir_path):
    os.makedirs(dir_path)
optionspath = '%s\\options.config' % dir_path
try:
    f = open(optionspath)
except IOError:
    print("File not accessible")
    f = open(optionspath,"w+")
    f.write("#MinerName,IP,User,Password,Port")
    f.close
finally:
    f.close()
try:
    minerconfig = genfromtxt(optionspath, skip_header=1, delimiter=",", dtype='unicode', loose=True, invalid_raise=False)
except IOError:
    print('Config Error')
finally:
    print('done')
snapconfspath = '%s\\snapconf.config' % dir_path
try:
    f = open(snapconfspath)
except IOError:
    print("File not accessible")
    f = open(snapconfspath,"w+")
    f.write("http://snapshots-wtf.sensecapmx.cloud/latest-snap.json\nhttp://snapshots-wtf.sensecapmx.cloud/snap-")
    f.close
finally:
    f.close()

class Ui_MainWindow(object):
    def setupUi(self, MainWindow):
        MainWindow.setObjectName("MainWindow")
        MainWindow.setFixedSize(1202, 792)
        MainWindow.resize(1202, 792)
        self.centralwidget = QtWidgets.QWidget(MainWindow)
        self.centralwidget.setObjectName("centralwidget")
        self.button_status = QtWidgets.QPushButton(self.centralwidget)
        self.button_status.setGeometry(QtCore.QRect(5, 662, 60, 41))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        font.setKerning(True)
        self.button_status.setFont(font)
        self.button_status.setObjectName("button_status")
        self.button_info = QtWidgets.QPushButton(self.centralwidget)
        self.button_info.setGeometry(QtCore.QRect(72, 662, 60, 41))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        font.setKerning(True)
        self.button_info.setFont(font)
        self.button_info.setObjectName("button_info")
        self.sync_status = QtWidgets.QPushButton(self.centralwidget)
        self.sync_status.setGeometry(QtCore.QRect(139, 662, 111, 41))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        font.setKerning(True)
        self.sync_status.setFont(font)
        self.sync_status.setObjectName("sync_status")
        self.button_peer_book = QtWidgets.QPushButton(self.centralwidget)
        self.button_peer_book.setGeometry(QtCore.QRect(257, 662, 111, 41))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        font.setKerning(True)
        self.button_peer_book.setFont(font)
        self.button_peer_book.setObjectName("button_peer_book")
        self.button_restart_miner = QtWidgets.QPushButton(self.centralwidget)
        self.button_restart_miner.setGeometry(QtCore.QRect(375, 662, 111, 41))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        font.setKerning(True)
        self.button_restart_miner.setFont(font)
        self.button_restart_miner.setObjectName("button_restart_miner")
        self.button_restart_lora = QtWidgets.QPushButton(self.centralwidget)
        self.button_restart_lora.setGeometry(QtCore.QRect(493, 662, 111, 41))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        font.setKerning(True)
        self.button_restart_lora.setFont(font)
        self.button_restart_lora.setObjectName("button_restart_lora")
        self.sync_resume = QtWidgets.QPushButton(self.centralwidget)
        self.sync_resume.setGeometry(QtCore.QRect(729, 662, 111, 41))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        font.setKerning(True)
        self.sync_resume.setFont(font)
        self.sync_resume.setObjectName("sync_resume")
        self.docker_console_log = QtWidgets.QPushButton(self.centralwidget)
        self.docker_console_log.setGeometry(QtCore.QRect(611, 662, 111, 41))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        font.setKerning(True)
        self.docker_console_log.setFont(font)
        self.docker_console_log.setObjectName("sync_status")
        self.disk_usage = QtWidgets.QPushButton(self.centralwidget)
        self.disk_usage.setGeometry(QtCore.QRect(847, 662, 111, 41))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        font.setKerning(True)
        self.disk_usage.setFont(font)
        self.disk_usage.setObjectName("disk_usage")
        self.button_fast_sync = QtWidgets.QPushButton(self.centralwidget)
        self.button_fast_sync.setGeometry(QtCore.QRect(965, 661, 111, 41))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        font.setKerning(True)
        self.button_fast_sync.setFont(font)
        self.button_fast_sync.setObjectName("button_fast_sync")
        self.button_quagga_restart = QtWidgets.QPushButton(self.centralwidget)
        self.button_quagga_restart.setGeometry(QtCore.QRect(1085, 661, 111, 41))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        font.setKerning(True)
        self.button_quagga_restart.setFont(font)
        self.button_quagga_restart.setObjectName("button_quagga_restart")
        self.button_send_command = QtWidgets.QPushButton(self.centralwidget)
        self.button_send_command.setGeometry(QtCore.QRect(1085, 710, 111, 41))
        font = QtGui.QFont()
        font.setPointSize(9)
        font.setBold(True)
        font.setWeight(75)
        self.button_send_command.setFont(font)
        self.button_send_command.setObjectName("button_send_command")
        self.line_command = QtWidgets.QLineEdit(self.centralwidget)
        self.line_command.setGeometry(QtCore.QRect(6, 710, 1070, 41))
        font = QtGui.QFont()
        font.setFamily("MS Shell Dlg 2")
        font.setPointSize(11)
        self.line_command.setFont(font)
        self.line_command.setObjectName("line_command")
        self.combo_select_miner = QtWidgets.QComboBox(self.centralwidget)
        self.combo_select_miner.setGeometry(QtCore.QRect(104, 3, 210, 26))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        self.combo_select_miner.setFont(font)
        self.combo_select_miner.setObjectName("combo_select_miner")
        self.label_select_miner = QtWidgets.QLabel(self.centralwidget)
        self.label_select_miner.setGeometry(QtCore.QRect(4, 1, 100, 31))
        font = QtGui.QFont()
        font.setPointSize(13)
        font.setBold(False)
        font.setWeight(50)
        self.label_select_miner.setFont(font)
        self.label_select_miner.setObjectName("label_select_miner")
        self.logo_milesight = QtWidgets.QPushButton(self.centralwidget)
        self.logo_milesight.setGeometry(QtCore.QRect(1100, 0, 101, 31))
        self.logo_milesight.setAutoFillBackground(False)
        self.logo_milesight.setText("")
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap(":/Logo/milesight-logo.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        self.logo_milesight.setIcon(icon)
        self.logo_milesight.setIconSize(QtCore.QSize(100, 200))
        self.logo_milesight.setCheckable(False)
        self.logo_milesight.setFlat(True)
        self.logo_milesight.setObjectName("logo_milesight")
        self.label_version = QtWidgets.QLabel(self.centralwidget)
        self.label_version.setGeometry(QtCore.QRect(1006, 8, 47, 13))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_version.setFont(font)
        self.label_version.setObjectName("label_version")
        self.label_version_numer = QtWidgets.QLabel(self.centralwidget)
        self.label_version_numer.setGeometry(QtCore.QRect(1060, 8, 41, 16))
        font = QtGui.QFont()
        font.setPointSize(10)
        self.label_version_numer.setFont(font)
        self.label_version_numer.setObjectName("label_version_numer")
        self.button_config_edit = QtWidgets.QPushButton(self.centralwidget)
        self.button_config_edit.setGeometry(QtCore.QRect(435, 2, 111, 28))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        font.setKerning(True)
        self.button_config_edit.setFont(font)
        self.button_config_edit.setObjectName("button_config_edit")
        self.button_config_reload = QtWidgets.QPushButton(self.centralwidget)
        self.button_config_reload.setGeometry(QtCore.QRect(550, 2, 111, 28))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        font.setKerning(True)
        self.button_config_reload.setFont(font)
        self.button_config_reload.setObjectName("button_config_reload")
        self.button_open_explorer = QtWidgets.QPushButton(self.centralwidget)
        self.button_open_explorer.setGeometry(QtCore.QRect(665, 2, 111, 28))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        font.setKerning(True)
        self.button_open_explorer.setFont(font)
        self.button_open_explorer.setObjectName("button_open_explorer")
        self.button_check_update = QtWidgets.QPushButton(self.centralwidget)
        self.button_check_update.setGeometry(QtCore.QRect(885, 2, 111, 28))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        font.setKerning(True)
        self.button_check_update.setFont(font)
        self.button_check_update.setObjectName("button_check_update")
        self.button_open_website = QtWidgets.QPushButton(self.centralwidget)
        self.button_open_website.setGeometry(QtCore.QRect(320, 2, 115, 28))
        font = QtGui.QFont()
        font.setPointSize(10)
        font.setBold(True)
        font.setWeight(75)
        font.setKerning(True)
        self.button_open_website.setFont(font)
        self.button_open_website.setObjectName("button_open_website")
        self.text_console = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.text_console.setGeometry(QtCore.QRect(6, 34, 1190, 621))
        self.text_console = QtWidgets.QPlainTextEdit(self.centralwidget)
        self.text_console.setGeometry(QtCore.QRect(6, 34, 1190, 621))
        font = QtGui.QFont()
        font.setFamily("Courier New")
        font.setPointSize(12)
        self.text_console.setFont(font)
        self.text_console.setObjectName("text_console")
        self.text_console.setStyleSheet("background-color:#212121;color:#A4E87F;background-image:url(:/Logo/logo.png);background-repeat:no-repeat;background-position:center right;")
        MainWindow.setCentralWidget(self.centralwidget)
        self.menubar = QtWidgets.QMenuBar(MainWindow)
        self.menubar.setGeometry(QtCore.QRect(0, 0, 1202, 21))
        self.menubar.setObjectName("menubar")
        self.menuFile = QtWidgets.QMenu(self.menubar)
        self.menuFile.setObjectName("menuFile")
        MainWindow.setMenuBar(self.menubar)
        self.statusbar = QtWidgets.QStatusBar(MainWindow)
        self.statusbar.setObjectName("statusbar")
        MainWindow.setStatusBar(self.statusbar)
        self.action_Exit = QtWidgets.QAction(MainWindow)
        self.action_Exit.setObjectName("action_Exit")
        self.action_Import_Config = QtWidgets.QAction(MainWindow)
        self.action_Import_Config.setObjectName("action_Edit_Config")
        self.action_Edit_Config = QtWidgets.QAction(MainWindow)
        self.action_Edit_Config.setObjectName("action_Edit_Config")
        self.action_Export_Config = QtWidgets.QAction(MainWindow)
        self.action_Export_Config.setObjectName("action_Export_Config")
        self.action_Edit_Snapshot = QtWidgets.QAction(MainWindow)
        self.action_Edit_Snapshot.setObjectName("action_Edit_Snapshot")
        self.menuFile.addAction(self.action_Edit_Config)
        self.menuFile.addAction(self.action_Import_Config)
        self.menuFile.addAction(self.action_Export_Config)
        self.menuFile.addAction(self.action_Edit_Snapshot)
        self.menuFile.addAction(self.action_Exit)
        self.menubar.addAction(self.menuFile.menuAction())

        self.retranslateUi(MainWindow)
        QtCore.QMetaObject.connectSlotsByName(MainWindow)
##################################################################
# Button Actions
        self.action_Edit_Config.triggered.connect(self.edit_config)
        self.action_Export_Config.triggered.connect(self.export_config)
        self.action_Import_Config.triggered.connect(self.import_config)
        self.action_Exit.triggered.connect(self.exit_window)
        self.action_Edit_Snapshot.triggered.connect(self.edit_snapshot)

        self.savepath = 'log.txt'
        self.s = ssh_comms.ssh_comms()

        self.button_config_reload.clicked.connect(self.updatecombo)
        self.button_config_edit.clicked.connect(self.edit_config)

#        self.button_send_command.clicked.connect(self.run_funk)
        self.button_send_command.clicked.connect(self.run_command_func)
        self.button_status.clicked.connect(self.status_but_func)
        self.button_info.clicked.connect(self.miner_info_func)
        self.button_peer_book.clicked.connect(self.run_peer_book_func)
        self.sync_resume.clicked.connect(self.sync_resume_func)
        self.sync_status.clicked.connect(self.sync_status_func)
        self.docker_console_log.clicked.connect(self.docker_console_log_func)
        self.disk_usage.clicked.connect(self.disk_usage_func)
        self.button_fast_sync.clicked.connect(self.update_but_func)
        self.button_quagga_restart.clicked.connect(self.quagga_but_func)
        self.button_check_update.clicked.connect(self.get_url_paths)
        self.button_open_website.clicked.connect(self.run_open_miner_website)
        self.button_restart_miner.clicked.connect(self.restart_miner_func)
        self.line_command.returnPressed.connect(self.run_command_func)
        self.button_restart_lora.clicked.connect(self.restart_lora_func)
        self.button_open_explorer.clicked.connect(self.open_explorer_func)
        self.logo_milesight.clicked.connect(self.open_milesight_func)

    def get_url_paths(self):
        #logf = open("error.log", "w")
        try:
            r = requests.get("https://api.github.com/repos/Secarius/Milesight_Miner_Tools/git/trees/main?recursive=1")
            data = r.json()
            url = [item['path'] for item in data['tree']]
            updatepackage = [string for string in url if 'minertools' in string]
            zippackage = [string for string in updatepackage if '.zip' in string]
            zippackage = zippackage[0]
            online_version = zippackage.replace(".zip", "")
            online_version = online_version.replace("installer/minertools_", "")
            if (version.parse(version_build) < version.parse(online_version)):
                self.update_fbdata(f'New Version availible!\n')
                updateurl = "https://github.com/Secarius/Milesight_Miner_Tools/raw/main/%s" % zippackage
                reply = QtWidgets.QMessageBox.question(self, 'Message',
                    "New Update availible. Do you want to update?", QtWidgets.QMessageBox.Yes | 
                    QtWidgets.QMessageBox.No, QtWidgets.QMessageBox.No)
                if reply == QtWidgets.QMessageBox.Yes:
                    self.update_fbdata(f'Downloading new Version....\n')
                    print('Downloading new Version')
                    urllib.request.urlretrieve(updateurl,"miner-update.zip")
                    self.update_fbdata(f'Downloading updater....\n')
                    print('Downloading updater')
                    urllib.request.urlretrieve("https://github.com/Secarius/Milesight_Miner_Tools/raw/main/installer/updater.zip","updater.zip")
                    self.update_fbdata(f'Extracting updater....\n')
                    print('extraction updater....')
                    with ZipFile('updater.zip', 'r') as zipOjk:
                        zipOjk.extractall()
                    updatepath = pathlib.Path().resolve()
                    updater = str(updatepath)
                    self.update_fbdata(f'Starting Update....\n')
                    print('starting update....')
                    Popen("%s\\updater\miner-update.exe" % updater)
                    sys.exit()
            else:
                self.update_fbdata(f'No Update availible!\n')
                reply = QtWidgets.QMessageBox.question(self, 'Message',
                    "No Update available", QtWidgets.QMessageBox.Ok)
        except Exception as e:     # most generic exception you can catch
            print(str(e))

    def check_update(self):
        #logf = open("error.log", "w")
        try:
            r = requests.get("https://api.github.com/repos/Secarius/Milesight_Miner_Tools/git/trees/main?recursive=1")
            data = r.json()
            url = [item['path'] for item in data['tree']]
            updatepackage = [string for string in url if 'minertools' in string]
            zippackage = [string for string in updatepackage if '.zip' in string]
            zippackage = zippackage[0]
            online_version = zippackage.replace(".zip", "")
            online_version = online_version.replace("installer/minertools_", "")
            if (version.parse(version_build) < version.parse(online_version)):
                self.update_fbdata(f'===================================================\n')
                self.update_fbdata(f'Version Status:  New Version availible!\n')
                self.update_fbdata(f'If you want to update, please press "Check Update".\n')
                self.update_fbdata(f'The update can take some time.\n')
                self.update_fbdata(f'===================================================\n')
            else:
                self.update_fbdata(f'=======================================\n')
                self.update_fbdata(f'Version Status: Miner Tools up to date!\n')
                self.update_fbdata(f'=======================================\n')
        except Exception as e:     # most generic exception you can catch
            print(str(e))

    def howto(self):
        self.update_fbdata(f'\n')
        self.update_fbdata(f'How to use the Miner Tools:\n')
        self.update_fbdata(f'\n')
        self.update_fbdata(f'Get started blog post from DCYeahThatsMe: \nhttps://denniscrawford.com/2022/02/milesight-ug65-minertools-guide-multiple-miner-config-by-secarius/\n')
        self.update_fbdata(f'\n')
        self.update_fbdata(f'Status:          get short status of miner docker container.\n')
        self.update_fbdata(f'Info:            get full info of miner docker container\n')
        self.update_fbdata(f'Sync Status:     see if sync ist active/paused\n')
        self.update_fbdata(f'Peer Book:       displays peerbook -s informations\n')
        self.update_fbdata(f'Restart Miner:   reboots the whole miner\n')
        self.update_fbdata(f'Restart Lora:    restarts the LoRa Packet Forwarder Service\n')
        self.update_fbdata(f'Console Log:     displays the miner docker console log\n')
        self.update_fbdata(f'Resume Sync:     tries to resume sync if paused\n')
        self.update_fbdata(f'Disk Usage:      displays the usage state of the miner disk\n')
        self.update_fbdata(f'Fast Sync:       triggers miner to fast sync the blockchain via snapshot download\n')
        self.update_fbdata(f'Quagga Restart:  restarts the Quagga Services\n')
        self.update_fbdata(f'\n')
        self.update_fbdata(f'Open in Browser: opens you miner ip in the browser\n')
        self.update_fbdata(f'Edit Config:     opens config in notepad to be edited\n')
        self.update_fbdata(f'Reload Config:   reloads config file\n')
        self.update_fbdata(f'Helium Explorer: opens miner on explorer.helium.com in the browser\n')
        self.update_fbdata(f'\n')
        self.update_fbdata(f'Check Update:    runs check for new version of Miner Tools and updates if wanted\n')
        self.update_fbdata(f'\n')
        self.update_fbdata(f'\n')
        self.update_fbdata(f'\n')
        self.update_fbdata(f'You can run custom commands in the free text field at the bottom, \njust type them and hit "Enter" / "Return" e.g. -> uptime\n')

    def updatecombo(self):
        global minerconfig
        try:
            f = open(optionspath)
        except IOError:
            print("File not accessible")
            f = open(optionspath,"w+")
            f.write("#MinerName,IP,User,Password,Port")
            f.close
        finally:
            f.close()
        try:
            minerconfig = genfromtxt(optionspath, skip_header=1, delimiter=",", dtype='unicode', loose=True, invalid_raise=False)
        except IOError:
                reply = QtWidgets.QMessageBox.question(self, 'Message',
                "There is error with the configfile\nIts located in: %appdata%\MinerTools", QtWidgets.QMessageBox.Ok)
        self.combo_select_miner.clear()
        if len(minerconfig.shape) > 1:
            for x in range(len(minerconfig)):
                self.combo_select_miner.addItem(minerconfig[x][0])
        else:
            if len(minerconfig.shape) == 1 and not minerconfig.shape == (0,):
                self.combo_select_miner.addItem(minerconfig[0])
            else:
                self.throw_custom_error(title='Error', message='Config is empty!')

    def open_milesight_func(self):
        webbrowser.open("https://www.milesight-iot.com/lorawan/hotspot-miner-helium/", new=0, autoraise=True)

    def run_open_miner_website(self):
        combopos = self.combo_select_miner.currentIndex()
        if len(minerconfig.shape) == 1 and not minerconfig.shape == (0,):
            addr = minerconfig[1]
        else:
            addr = minerconfig[combopos][1]
        minerurl = 'http://%s/' % addr
        webbrowser.open(minerurl, new=0, autoraise=True)
        
    def edit_config(self):
        os.system('notepad.exe ' + optionspath)
        self.updatecombo()

    def edit_snapshot(self):
        os.system('notepad.exe ' + snapconfspath)
        self.updatecombo()

    def export_config(self):
        name = QtWidgets.QFileDialog.getSaveFileName(self, 'Save File')
        if not name[0] == '':
            with open(optionspath) as f:
                with open(name[0], "w") as f1:
                    for line in f:
                        f1.write(line)
                f1.close()
            f.close()
        self.updatecombo()

    def import_config(self):
        name = QtWidgets.QFileDialog.getOpenFileName(self, 'Open File')
        if not name[0] == '':
            with open(name[0]) as f:
                with open(optionspath, "w") as f1:
                    for line in f:
                        f1.write(line)
                f1.close()
            f.close()
        self.updatecombo()

    def exit_window(self):
        qApp.quit()

    def run_sync_commands(self):
        self.update_fbdata(f'Syncing . . . This might take a minute . . .\n')
        self.log = ''
        f = open(snapconfspath)
        snaplines = f.readlines()
        snapurl = snaplines[0]
        snapurlsnap = snaplines[1]
        f.close
        height = '** ERROR WHILE EXECUTING CURL CMD **'
        cmds = ['docker exec miner miner repair sync_pause',
                'docker exec miner miner repair sync_cancel',
                'curl %s' % snapurl,
                'cd /mnt/mmcblk0p1/miner_data/snap && rm snap-*',
                'cd /mnt/mmcblk0p1/miner_data/snap && wget %s' % snapurlsnap,
                'docker exec miner miner snapshot load /var/data/snap/snap- &',
                'docker exec miner miner repair sync_state',
                'docker exec miner miner repair sync_resume']
        do_sync_resume = False
        for idx, cmd in enumerate(cmds):
            if idx == 7 and do_sync_resume: # sync resume
                chk = True
                while chk:
                    self.update_fbdata(f'${cmd}\n')
                    out, stderr = self.s.exec_cmd(cmd=cmd)
                    self.update_fbdata(out)
                    if stderr != '': self.update_fbdata(f'STDERR: {stderr}')
                    self.log += f'#{cmd}\n{out}'
                    if stderr != '': self.log += f'STDERR: {stderr}'
                    chk = 'failed' in out
                    self.text_console.ensureCursorVisible()
            else:
                if idx == 4: # wget
                    cmd += height
                elif idx == 5: # snapshot load
                    cmd = f"{cmd.split(' &')[0]}{height}{cmd.split('snap-')[1]}"
                self.update_fbdata(f'${cmd}\n')
                out, stderr = self.s.exec_cmd(cmd=cmd)
                self.update_fbdata(out)
                if stderr != '':
                    if idx == 4: stderr = '\n'.join(stderr.split('\n')[:13])+'\n'+' '*30+'..........\n'+'\n'.join(stderr.split('\n')[-10:])
                    self.update_fbdata(f'STDERR: {stderr}')
                if idx == 2: # curl
                    height = out.split('height":')[1].split('}')[0]
                elif idx == 6: # sync_state
                    do_sync_resume = 'sync active' not in out
                self.log += f'#{cmd}\n{out}'
                if stderr != '': self.log += f'STDERR: {stderr}'
        self.update_fbdata(f'*** DONE ***\n')
        self.text_console.ensureCursorVisible()
        self.save()
        self.s.disconnect()

    #*************************** BUTTON FUNCTIONS ***************************
    def sync_status_func(self):
        if not self.s.is_alive():
            if self.conn_sequence() == None:
                return
            self.tmpthread = threading.Thread(target=self.run_sync_status_log_cmd)
            self.tmpthread.daemon = True
            self.tmpthread.start()
        else:
            self.throw_custom_error(title='Error', message='Another function already in progress. Please be patient.')

    def docker_console_log_func(self):
        if not self.s.is_alive():
            if self.conn_sequence() == None:
                return
            self.tmpthread = threading.Thread(target=self.docker_console_log_cmd)
            self.tmpthread.daemon = True
            self.tmpthread.start()
        else:
            self.throw_custom_error(title='Error', message='Another function already in progress. Please be patient.')

    def restart_miner_func(self):
        if not self.s.is_alive():
            if self.conn_sequence() == None:
                return
            self.tmpthread = threading.Thread(target=self.run_restart_miner_cmd)
            self.tmpthread.daemon = True
            self.tmpthread.start()
        else:
            self.throw_custom_error(title='Error', message='Another function already in progress. Please be patient.')

    def disk_usage_func(self):
        if not self.s.is_alive():
            if self.conn_sequence() == None:
                return
            self.tmpthread = threading.Thread(target=self.run_disk_usage_cmd)
            self.tmpthread.daemon = True
            self.tmpthread.start()
        else:
            self.throw_custom_error(title='Error', message='Another function already in progress. Please be patient.')

    def update_but_func(self):
        if not self.s.is_alive():
            if self.conn_sequence() == None:
                return
            self.tmpthread = threading.Thread(target=self.run_sync_commands)
            self.tmpthread.daemon = True
            self.tmpthread.start()
        else:
            self.throw_custom_error(title='Error', message='Another function already in progress. Please be patient.')

    def quagga_but_func(self):
        if not self.s.is_alive():
            if self.conn_sequence() == None:
                return
            self.tmpthread = threading.Thread(target=self.run_quagga_cmd)
            self.tmpthread.daemon = True
            self.tmpthread.start()
        else:
            self.throw_custom_error(title='Error', message='Another function already in progress. Please be patient.')

    def restart_lora_func(self):
        if not self.s.is_alive():
            if self.conn_sequence() == None:
                return
            self.tmpthread = threading.Thread(target=self.run_restart_lora_cmd)
            self.tmpthread.daemon = True
            self.tmpthread.start()
        else:
            self.throw_custom_error(title='Error', message='Another function already in progress. Please be patient.')

    def status_but_func(self):
        if not self.s.is_alive():
            if self.conn_sequence() == None:
                return
            self.tmpthread = threading.Thread(target=self.run_status_cmd)
            self.tmpthread.daemon = True
            self.tmpthread.start()
        else:
            self.throw_custom_error(title='Error', message='Another function already in progress. Please be patient.')

    def miner_info_func(self):
        if not self.s.is_alive():
            if self.conn_sequence() == None:
                return
            self.tmpthread = threading.Thread(target=self.run_miner_info_cmd)
            self.tmpthread.daemon = True
            self.tmpthread.start()
        else:
            self.throw_custom_error(title='Error', message='Another function already in progress. Please be patient.')

    def run_peer_book_func(self):
        if not self.s.is_alive():
            if self.conn_sequence() == None:
                return
            self.tmpthread = threading.Thread(target=self.run_peer_book_cmd)
            self.tmpthread.daemon = True
            self.tmpthread.start()
        else:
            self.throw_custom_error(title='Error', message='Another function already in progress. Please be patient.')

    def run_command_func(self):
        if not self.s.is_alive():
            if self.conn_sequence() == None:
                return
            self.tmpthread = threading.Thread(target=self.run_line_command_cmd)
            self.tmpthread.daemon = True
            self.tmpthread.start()
        else:
            self.throw_custom_error(title='Error', message='Another function already in progress. Please be patient.')

    def sync_resume_func(self):
        if not self.s.is_alive():
            if self.conn_sequence() == None:
                return
            self.tmpthread = threading.Thread(target=self.run_sync_resume)
            self.tmpthread.daemon = True
            self.tmpthread.start()
        else:
            self.throw_custom_error(title='Error', message='Another function already in progress. Please be patient.')
    #*************************** BUTTON FUNCTIONS ***************************

    def open_explorer_func(self):
        if not self.s.is_alive():
            if self.conn_sequence() == None:
                return
            self.tmpthread = threading.Thread(target=self.run_open_explorer_cmd)
            self.tmpthread.daemon = True
            self.tmpthread.start()
        else:
            self.throw_custom_error(title='Error', message='Another function already in progress. Please be patient.')

    def run_quagga_cmd(self):
        cmd = '/etc/init.d/quagga restart'
        self.update_fbdata(f'${cmd}\n')
        out, stderr = self.s.exec_cmd(cmd=cmd)
        self.update_fbdata(out)
        if stderr != '': self.update_fbdata(f'STDERR: {stderr}')
        self.update_fbdata(f'*** DONE ***\n')
        self.s.disconnect()

    def run_open_explorer_cmd(self):
        cmds = ['docker exec miner miner info onboarding']
        self.update_fbdata(f'Generating Helium Explorer Link ...\n')
        for idx, cmd in enumerate(cmds):
            out, stderr = self.s.exec_cmd(cmd=cmd)
            if stderr != '': self.update_fbdata(f'STDERR: {stderr}')
            miner_addr = out.split('publicAddress')[1].split('|')[1].split('|')[0]
        minerurl = 'https://explorer.helium.com/hotspots/%s' % miner_addr
        webbrowser.open(minerurl, new=0, autoraise=True)
        self.update_fbdata(f'*** DONE ***\n')
        self.s.disconnect()

    def run_status_cmd(self):
        cmds = ['docker exec miner miner info p2p_status',
                'curl -k --connect-timeout 10 https://api.helium.io/v1/blocks/height',
                'cat /sys/class/thermal/thermal_zone0/temp']
        self.update_fbdata(f'${cmds[0]}\n')
        for idx, cmd in enumerate(cmds):
            out, stderr = self.s.exec_cmd(cmd=cmd)
            if idx == 0:
                self.update_fbdata(out)
                if stderr != '': self.update_fbdata(f'STDERR: {stderr}')
                miner_height = int(out.split('height')[1].split('|')[1].split('|')[0])
            elif idx == 1:
                blockchain_height = int(out.split('height":')[1].split('}')[0])
            elif idx == 2:
                cpu_temp = int(out)
        temp = cpu_temp / 1000
        self.update_fbdata(f'CPU Temperature: {temp}°C\n\n')
        diff = miner_height - blockchain_height
        self.update_fbdata(f'Blockchain height: %s\n' % blockchain_height)
        self.update_fbdata(f'Miner height: %s\n\n' % miner_height)
        if diff > 0:
            self.update_fbdata(f'-> Miner {diff} blocks ahead of the blockchain! (SYNCED)\n')
        elif diff < 0:
            self.update_fbdata(f'-> Miner trailing {diff} blocks behind the blockchain. (SYNCING)\n')
        else:
            self.update_fbdata(f'-> Miner in complete sync with the blockchain! (SYNCED)\n')
        self.update_fbdata(f'*** DONE ***\n')
        self.s.disconnect()

    def run_restart_lora_cmd(self):
        cmds = ['/etc/init.d/lora_pkt_fwd stop',
                '/etc/init.d/lora_pkt_fwd start',
                'ps | grep lora_pkt_fwd']
        self.update_fbdata(f'Restarting LoRA Packet Forwarder...\n')
        for idx, cmd in enumerate(cmds):
            self.update_fbdata(f'${cmd}\n')
            out, stderr = self.s.exec_cmd(cmd=cmd)
            self.update_fbdata(out)
            self.update_fbdata(f'\n')
        self.update_fbdata(f'*** DONE ***\n')
        self.s.disconnect()

    def run_miner_info_cmd(self):
        cmd = 'docker exec miner miner info summary'
        self.update_fbdata(f'${cmd}\n')
        out, stderr = self.s.exec_cmd(cmd=cmd)
        self.update_fbdata(out)
        if stderr != '': self.update_fbdata(f'STDERR: {stderr}')
        self.update_fbdata(f'*** DONE ***\n')
        self.s.disconnect()

    def run_restart_miner_cmd(self):
        cmd = 'reboot now'
        self.update_fbdata(f'${cmd}\n')
        out, stderr = self.s.exec_cmd(cmd=cmd)
        self.update_fbdata(out)
        if stderr != '': self.update_fbdata(f'STDERR: {stderr}')
        self.update_fbdata(f'*** DONE ***\n')
        self.s.disconnect()

    def run_sync_status_log_cmd(self):
        cmd = 'docker exec miner miner repair sync_state'
        self.update_fbdata(f'${cmd}\n')
        out, stderr = self.s.exec_cmd(cmd=cmd)
        self.update_fbdata(out)
        if stderr != '': self.update_fbdata(f'STDERR: {stderr}')
        self.update_fbdata(f'*** DONE ***\n')
        self.s.disconnect()

    def run_disk_usage_cmd(self):
        cmd = 'df -h /mnt/mmcblk0p1'
        self.update_fbdata(f'${cmd}\n')
        out, stderr = self.s.exec_cmd(cmd=cmd)
        self.update_fbdata(out)
        if stderr != '': self.update_fbdata(f'STDERR: {stderr}')
        self.update_fbdata(f'*** DONE ***\n')
        self.s.disconnect()

    def docker_console_log_cmd(self):
        cmd = 'docker exec miner cat /var/data/log/console.log'
        self.update_fbdata(f'${cmd}\n')
        out, stderr = self.s.exec_cmd(cmd=cmd)
        self.update_fbdata(out)
        if stderr != '': self.update_fbdata(f'STDERR: {stderr}')
        self.update_fbdata(f'*** DONE ***\n')
        self.s.disconnect()

    def run_peer_book_cmd(self):
        cmd = 'docker exec miner miner peer book -s'
        self.update_fbdata(f'${cmd}\n')
        out, stderr = self.s.exec_cmd(cmd=cmd)
        self.update_fbdata(out)
        if stderr != '': self.update_fbdata(f'STDERR: {stderr}')
        self.update_fbdata(f'*** DONE ***\n')
        self.s.disconnect()

    def run_line_command_cmd(self):
        cmd = self.line_command.text()
        self.update_fbdata(f'${cmd}\n')
        out, stderr = self.s.exec_cmd(cmd=cmd)
        self.update_fbdata(out)
        if stderr != '': self.update_fbdata(f'STDERR: {stderr}')
        self.update_fbdata(f'*** DONE ***\n')
        self.s.disconnect()

    def run_sync_resume(self):
        cmd = 'docker exec miner miner repair sync_resume'
        self.update_fbdata(f'${cmd}\n')
        out, stderr = self.s.exec_cmd(cmd=cmd)
        self.update_fbdata(out)
        if stderr != '': self.update_fbdata(f'STDERR: {stderr}')
        self.update_fbdata(f'*** DONE ***\n')
        self.s.disconnect()

# Connect Sequence
    def conn_sequence(self):
        combopos = self.combo_select_miner.currentIndex()
        if len(minerconfig.shape) == 1 and not minerconfig.shape == (0,):
            addr = minerconfig[1]
            user = minerconfig[2]
            passwd = minerconfig[3]
            port = minerconfig[4]
        else:
            addr = minerconfig[combopos][1]
            user = minerconfig[combopos][2]
            passwd = minerconfig[combopos][3]
            port = minerconfig[combopos][4]
        if addr[-1] == 'X':
            self.throw_custom_error(title='Error', message='Enter device IP address.')
            return None
        if not self.validate_ip_address(addr):
            self.throw_custom_error(title='Error', message='Invalid IP address.')
            return None
        if any([x==None for x in [user, passwd]]):
            self.throw_custom_error(title='Error', message='Error reading options.config file.')
            return None
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(1)
        if sock.connect_ex((addr, int(port))) != 0:
            sock.close()
            self.throw_trouble_connecting_error()
            return None
        sock.close()
        self.s.set_config(addr=addr, user=user, port=port, password=passwd)
        connection = self.s.connect()
        self.clear_fbdata()
        if not self.s.is_alive() or connection == None:
            self.update_fbdata(f'Connection Error.\nCheck username and password in options.config in files/ folder.')
            return None
        return True

    def update_fbdata(self, d):
        self.text_console.insertPlainText(d)

    def clear_fbdata(self):
        self.text_console.clear()

    def validate_ip_address(self, address):
        try:
            ip = ipaddress.ip_address(address)
            return True
        except ValueError:
            return False

    def save(self):
        try:
            with open(self.savepath, 'w') as f:
                f.write(self.log)
        except Exception as e:
            self.throw_custom_error('ERROR', 'Error trying to save log file.')
            print(f'e : {e}')
#*************************** BUTTON FUNCTIONS ***************************

#**************************** THROW ERROR ****************************
    def throw_trouble_connecting_error(self):
        messagebox.showwarning(title='ERROR', message='Having trouble connecting to device.')

    def throw_custom_error(self, title, message):
        messagebox.showwarning(title=title, message=message)
#**************************** THROW ERROR ****************************

##################################################################
    def retranslateUi(self, MainWindow):
        _translate = QtCore.QCoreApplication.translate
        MainWindow.setWindowTitle(_translate("MainWindow", "Miner Tools"))
        self.button_status.setText(_translate("MainWindow", "Status"))
        self.button_info.setText(_translate("MainWindow", "Info"))
        self.sync_resume.setText(_translate("MainWindow", "Resume Sync"))
        self.button_peer_book.setText(_translate("MainWindow", "Peer Book"))
        self.button_restart_miner.setText(_translate("MainWindow", "Restart Miner"))
        self.button_restart_lora.setText(_translate("MainWindow", "Restart Lora"))
        self.sync_status.setText(_translate("MainWindow", "Sync Status"))
        self.docker_console_log.setText(_translate("MainWindow", "Console Log"))
        self.disk_usage.setText(_translate("MainWindow", "Disk Usage"))
        self.button_fast_sync.setText(_translate("MainWindow", "Fast Sync"))
        self.button_quagga_restart.setText(_translate("MainWindow", "Quagga Restart"))
        self.button_send_command.setText(_translate("MainWindow", "Send Command"))
        self.line_command.setText(_translate("MainWindow", "docker exec miner miner versions"))
        self.label_select_miner.setText(_translate("MainWindow", "Select Miner:"))
        self.label_version.setText(_translate("MainWindow", "Version:"))
        self.label_version_numer.setText(_translate("MainWindow", version_build))
        self.button_config_edit.setText(_translate("MainWindow", "Edit Config"))
        self.button_config_reload.setText(_translate("MainWindow", "Reload Config"))
        self.button_open_explorer.setText(_translate("MainWindow", "Helium Explorer"))
        self.button_check_update.setText(_translate("MainWindow", "Check Update"))
        self.button_open_website.setText(_translate("MainWindow", "Open in Browser"))
        self.menuFile.setTitle(_translate("MainWindow", "File"))
        self.action_Exit.setText(_translate("MainWindow", "Exit"))
        self.action_Edit_Config.setText(_translate("MainWindow", "Edit Config"))
        self.action_Export_Config.setText(_translate("MainWindow", "Export Config"))
        self.action_Import_Config.setText(_translate("MainWindow", "Import Config"))
        self.action_Edit_Snapshot.setText(_translate("MainWindow", "Edit Snap URL"))